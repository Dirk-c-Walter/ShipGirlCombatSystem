/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package jessy.shipgirlcombatsystem.screens;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.RenderingHints;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.geom.AffineTransform;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import jessy.shipgirlcombatsystem.commands.Command;
import jessy.shipgirlcombatsystem.map.BoardItem;
import jessy.shipgirlcombatsystem.map.Hex;
import jessy.shipgirlcombatsystem.map.HexMap;
import jessy.shipgirlcombatsystem.map.Player;
import jessy.shipgirlcombatsystem.net.Client;
import jessy.shipgirlcombatsystem.ship.Ship;
import jessy.shipgirlcombatsystem.util.MathUtil;
import jessy.shipgirlcombatsystem.util.Phase;
import static jessy.shipgirlcombatsystem.util.Phase.WAIT_PHASE;
import jessy.shipgirlcombatsystem.util.ThriftUtil;
import org.apache.thrift.TException;
import org.apache.thrift.transport.TTransportException;

/**
 *
 * @author dirk
 */
public class MapPanel extends javax.swing.JPanel {
    private HexMap startOfTurn = new HexMap(10);
    private HexMap current = new HexMap(startOfTurn);
    private int side;
    private int height;
    private Point translation = new Point(0,0);
    private static MapPanel instance;
    public static ShipPanel shipPanel;
    private LinkedList<Command> commands = new LinkedList<>();
    private LinkedHashMap<Hex, Overlay> overlay = new LinkedHashMap<>();
    private Player player;
    private Client client;

    /**
     * Creates new form MapPanel
     */
    public MapPanel() {
        setSize(8);
        final int r = startOfTurn.getRadious();
        translation.x = r * side * 2 + 50;
        translation.y = r * height * 2 + 50;
        initComponents();
        
        DebugMouseListener ml = new DebugMouseListener();            
        addMouseListener(ml);
        addMouseWheelListener(ml);
        addMouseMotionListener(ml);
        
        instance = this;
    }
    
    public HexMap getBoard() {
        return current;
    }
    
    public static MapPanel getInstance() {
        return instance;
    }
    
    public void applyNewTurn(final HexMap newTurn, Phase phase) {
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                startOfTurn = newTurn;
                current = new HexMap(startOfTurn);
                commands = new LinkedList<>();
                repaint();
            } 
        });
    }
    
    public void applyNewTurnAndWait(final HexMap newTurn, Phase phase) throws InterruptedException, InvocationTargetException {
        SwingUtilities.invokeAndWait(new Runnable() {
            @Override
            public void run() {
                startOfTurn = newTurn;
                current = new HexMap(startOfTurn);
                commands = new LinkedList<>();
                repaint();
            } 
        });
    }
    
    private void setSize(int size) {
        if(size <4 ) {
            size = 4;
        }
        side = size; //half an edgelength
        height = (int) Math.ceil(MathUtil.SQRT_3 * side);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(102, 102, 102));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    @Override
    public void paintComponent(Graphics g) {
        Graphics2D g2 = (Graphics2D) g;
        final AffineTransform oldTransform = g2.getTransform();
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setFont(new Font("TimesRoman", Font.PLAIN, 12));
        super.paintComponent(g2);
        
        final int r = current.getRadious();
        //draw grid
        for (int i = -r; i < r; i++) {
            for (int j = -r; j < r; j++) {
                drawHex(i, j, g2);
            }
        }
        g2.translate(translation.x, translation.y);
        for (int i = -r; i < r; i++) {
            for (int j = -r; j < r; j++) {
                final Hex ijHex = new Hex(i, j);
                for(BoardItem item : current.getEntitiesAt(ijHex)) {
                    if(item.drawable()) {
                        item.drawItem(g2, ijHex, side, height);
                    }
                }
            }
        }
        
        g2.setTransform(oldTransform);
    }
    
    public void addCommand(final Command c) {
        if(c.appliesToPhase(current.getPhase())) {
            commands.add(c);
            SwingUtilities.invokeLater(new Runnable() {
                @Override
                public void run() {
                    c.applyCommand(current);
                    repaint();
                }
            });
        }
    }
    
    public void sendCommands() {
        assert(client != null);
        if(current.getPhase() == WAIT_PHASE) {
            JOptionPane.showConfirmDialog(this, "Please wait for the other players.");
            return;
        }
        final LinkedList<Command> cmd = commands;
        final HexMap cur = current;
        current.setPhase(Phase.WAIT_PHASE);
        ThriftUtil.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    HexMap newTurn = client.doneTurn(cmd, cur, startOfTurn.getPhase());
                    applyNewTurn(newTurn, newTurn.getPhase());
                } catch (TException ex) {
                    Logger.getLogger(MapPanel.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            
        });
        commands = new LinkedList<>();
    }
    
    public void undoCommand() {
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                if(!commands.isEmpty()) {
                    commands.pop().undoCommand(current);
                    repaint();
                }
            }
        });
    }
    
    private void drawHex(int i, int j, Graphics2D g2) {
        final Hex h = new Hex(i, j);
        Polygon poly = h.hex(side, height);
        poly.translate(translation.x, translation.y);
        g2.setColor(current.getColorHex(h));
        final Overlay over = overlay.get(h);
        if(over != null) {
            g2.setColor(over.getHexColor());
        }

        g2.fillPolygon(poly);
        g2.setColor(Color.WHITE);
        if(over != null && over.text != null && !over.text.isEmpty()) {
            Point p = h.toPixel(2*side);
            g2.drawString(over.text, translation.x +p.x, translation.y+p.y);
        }
        g2.drawPolygon(poly);
        
    }

    public Player getPlayerData() {
        return player;
    }
    
    public void setPlayer(Player p) {
        player = p;
    }
    
    public String connectTo(String hostname) throws IOException {
        assert(player != null && client == null);
        try {
            client = new Client(hostname);
            return client.join(player);
        } catch (TTransportException ex) {
            Logger.getLogger(MapPanel.class.getName()).log(Level.SEVERE, null, ex);
        } catch (TException ex) {
            Logger.getLogger(MapPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        return "Failure";
    }
    
    public Client getClient() {
        return client;
    }

    private class DebugMouseListener extends MouseAdapter {
        private boolean measureMode = false;
        private Hex measureStart = null;
        private int lastItemIndex;
        private Hex lastHex;
        private Point clickSource = null;
                
        @Override
        public void mousePressed(MouseEvent e) {
            clickSource = e.getPoint();
        }

        @Override
        public void mouseReleased(MouseEvent e) {
            clickSource = null;
        }

        @Override
        public void mouseExited(MouseEvent e) {
            clickSource = null;
        }

        @Override
        public void mouseMoved(MouseEvent e) {
            if(measureMode) {
                overlay.clear();
                int x = e.getX() - translation.x;
                int y = e.getY() - translation.y;
                final Hex a = Hex.pixelToHex(new Point(x,y), side*2);
                List<Hex> line = measureStart.getLine(a);
                for(int i =0; i < line.size(); i++) {
                    overlay.put(line.get(i), new Overlay(""+i));
                }
                repaint();
            }
        }
       
        @Override
        public void mouseDragged(MouseEvent e) {
            if(clickSource != null) {
                int dx = e.getX() - clickSource.x;
                int dy = e.getY() - clickSource.y;
                translation.x += dx;
                translation.y += dy;
                clickSource = e.getPoint();
    //            System.out.println("Drag; " + e.paramString());
                repaint();
            }
        }


        @Override
        public void mouseWheelMoved(MouseWheelEvent e) {
            int adjust = e.getUnitsToScroll();
            
            int size = side + adjust;
            setSize(size);
            
  //          System.out.println("Scroll; " + adjust);
            repaint();
        }
        
        @Override
        public void mouseClicked(final MouseEvent e) {
            int x = e.getX() - translation.x;
            int y = e.getY() - translation.y;
            final Hex a = Hex.pixelToHex(new Point(x,y), side*2);
            BoardItem[] list = current.getEntitiesAt(a).toArray(new BoardItem[0]);
            System.out.println("Hit: (" + x+ "," +y+ "): " + e.getButton() + " - " + Hex.pixelToHex(new Point(x,y), side*2));
            if(measureMode) {
                measureMode = false;
            }
            if(e.getButton() == MouseEvent.BUTTON1) {
                if(!a.equals(lastHex)) {
                    lastHex = a;
                    lastItemIndex = 0;
                }

                if(list.length > 0) {
                    final int fullLength = lastItemIndex + list.length+1;
                    for(int i = lastItemIndex+1; i < fullLength; i++) {
                        if(list[i%list.length] instanceof Ship) {
                            selectShip((Ship) list[i%list.length]);
                            lastItemIndex = i;
                            break;
                        }
                    }
                }
            } else if (e.getButton() == MouseEvent.BUTTON3) {
                JPopupMenu menu = new JPopupMenu();
                if(list.length > 0) {
                    for(BoardItem item : list) {
                        if(item instanceof Ship) {
                            final Ship ship = (Ship) item;
                            JMenuItem menuItem = new JMenuItem(ship.getName());
                            menuItem.setEnabled(item.selectable());
                            menuItem.addActionListener(new ActionListener() {
                                @Override
                                public void actionPerformed(ActionEvent e) {
                                    selectShip(ship);
                                }
                            });
                            menu.add(menuItem);
                        }
                    }
                    menu.addSeparator();
                }
                JMenuItem menuItem = new JMenuItem("Draw Line");
                menuItem.addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        measureStart = a;
                        measureMode = true;
                    }
                });
                menuItem.setEnabled(true);
                menu.add(menuItem);
                
                menu.show(instance, e.getX(), e.getY());
            }
        }

        private void selectShip(Ship ship) {
            shipPanel.updateShip(ship);
        }
    }
    
    private static class Overlay {
        private final String text;

        public Overlay(String text) {
            this.text = text;
        }
        
        public Color getHexColor() {
            return Color.BLUE;
        }
    }
}
